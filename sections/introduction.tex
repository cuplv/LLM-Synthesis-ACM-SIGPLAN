\section{Introduction}


% Problem statement and motivation: LLMs are used to write code and synthesize programs - they can be quite good at it but they suffer from hallucinations ... contrast this with other program synthesis techniques

% Novelty/ Motivate our contribution: Existing taxonomies only consider full queries but let's look at the mistakes made at the lexeme level

% We categorize them and see oh wow we can use some symbolic techniques that improve LLM generation

% taxonomy is a downstream to characterize effectiveness of program synthesis techniques during decoding - so clearly - categorize at lexeme level how constrained decoding work at lexeme level -

\jedi{LLMs are used for program synthesis, but errors can compound if the LLM starts off on the wrong track.} Large Language Models (LLMs) are increasingly used as program generators to synthesize working code from natural language prompts. In contrast to other program synthesis techniques, LLMs are scalable to larger and more complex programs; however, due to their autoregressive nature, they can get stuck down an incorrect path as errors can propagate throughout the decoding process which ultimately produces invalid programs.

\jedi{Constrained decoding has shown to improve generation of syntactically valid and typesafe programs by enforcing constraints at decoding time, but constrained decoding techniques with richer semantic constraints, such as those likely required to effectively synthesize SQL queries, have yet to be developed.}

\jedi{In this paper we study the use of LLMs to synthesize SQL queries; categorizing the mistakes they make to evaluate whether constrained decoding or other symbolic reasoning techniques could steer LLMs to correct queries.}

\jedi{LLMs predict queries token by token and constrained decoding enforces constraints at decoding time, so we focus our study on the incremental errors LLMs make.} Recent LLM augmented program synthesis techniques have focused on enforcing constraints at decoding time to ensure certain properties \cite{chopchop}. These techniques are often evaluated in terms of final outputs. However, constrained decoding operates at the lexeme level. To understand its effectiveness, we must analyze the model's learned distribution for lexemes during decoding, since a constraint can only be enforced if the appropriate lexeme appears within the model’s top-k candidates.

\jedi{Existing SQL error taxonomies are based on fully generated queries, so we introduce a new taxonomy focusing on the incremental errors LLMs make.} We conduct our lexeme-level analysis on a subspace of the program synthesis domain, the text-to-SQL task, as the correctness of an SQL query can be accurately assessed. Existing taxonomies analyze errors of fully generated queries \cite{qu2024generationalignitnovel}. However, SQL synthesis is particularly dependent on lexeme-level correctness. In addition to overall query structure, SQL queries are dependent on correct schema references and correct operator usage.

\jedi{A taxonomy of incremental SQL prediction errors then allows us to observe the potential benefit of symbolic repair and the limitations of constrained decoding for LLM-driven SQL synthesis.} We evaluate the ability of LLMs to synthesize correct SQL queries at the lexeme level and find that we can broadly categorize lexeme level errors into six categories.  We find that many errors within these categories can be mitigated with simple symbolic fixes and constrained decoding. We also observe limitations of constrained decoding. It cannot correct errors if the correct lexeme is absent from the model’s top-k candidates.

\textbf{Contributions:}
\begin{itemize}
    \item We present a hierarchical taxonomy of error categorization for lexeme level LLM mistakes during the decoding process.
    \item We identify error categories that are amenable to symbolic repair and quantify an upper bound on automatically correctable failures.
    \item We introduce a constrained decoding methodology, \textit{schema constrained decoding} to address schema-based errors.
\end{itemize}
